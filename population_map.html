<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<link rel="stylesheet" type="text/css" href="style.css">


<h2>Total Population in Asia (2024)</h2>

<svg id="population_map" width="1000" height="800"></svg>

<script>
  const svg = d3.select("#population_map");
  const width = svg.attr("width");
  const height = svg.attr("height");

  //create a map projection
  const projection = d3.geoMercator()
    .scale(250)
    .center([90, 50])
    .translate([width / 2, height / 2]);
  const path = d3.geoPath().projection(projection);

  //stores country and population 
  let data = d3.map();
  //array to store pop. values
  let populationValues = [];

  d3.csv("project-data.csv", function (d) {
    //remove comma and convert to number 
    d["Population (2024)"] = +d["Population (2024)"].replace(/,/g, '');
    data.set(d["Country (or dependency)"], d["Population (2024)"]);
    populationValues.push(d["Population (2024)"]);
  }, function (error, rows) {
    if (error) throw error;

    // min, max of population for scale
    const populationExtent = d3.extent(populationValues);
    const minPopulation = populationExtent[0];
    const maxPopulation = populationExtent[1];

    // color scale 
    const colorScale = d3.scaleThreshold()
      .domain([minPopulation, minPopulation * 10, minPopulation * 50, minPopulation * 100, maxPopulation * 0.5, maxPopulation])
      .range(d3.schemeOranges[7]);

    // load GeoJSON data and render the map
    d3.json("updated_world.geojson", function (error, world) {
      if (error) throw error;

      let asiaCountriesList = [
        "Afghanistan", "Armenia", "Azerbaijan", "Bangladesh",
        "Bhutan", "Brunei", "Cambodia", "China", "Cyprus", "Georgia",
        "India", "Indonesia", "Iran", "Iraq", "Israel", "Japan", "Jordan",
        "Kazakhstan", "Kuwait", "Kyrgyzstan", "Laos", "Lebanon", "Malaysia",
        "Mongolia", "Myanmar", "Nepal", "North Korea", "Oman",
        "Pakistan", "Palestine", "Philippines", "Qatar", "Russia", "Saudi Arabia",
        "South Korea", "Sri Lanka", "Syria", "Taiwan", "Tajikistan",
        "Thailand", "Timor-Leste", "Turkey", "Turkmenistan", "United Arab Emirates",
        "Uzbekistan", "Vietnam", "Yemen", "Singapore", "Bahrain", "Maldives"
      ];

      //filter to only include asian countries from world GEoJson
      let asiaCountries = world.features.filter(function (d) {
        return asiaCountriesList.includes(d.properties.name);
      });

      // drawing the map
      svg.append("g")
        .selectAll("path")
        .data(asiaCountries)
        .enter()
        .append("path")
        .attr("class", "country")
        .attr("d", path)
        .attr("fill", d => {
          const population = data.get(d.properties.name);
          if (population) {
            return colorScale(population);
          } else {
            return "#ccc";
          }
        });

      // legend
      let legend = svg.append("g")
        .attr("transform", "translate(20,40)");

      legend.append("text")
        .attr("x", 0)
        .attr("y", 0)
        .attr("class", "legend-title")
        .text("Population Scale");


      const legendData = colorScale.domain();

      const legendLabels = legendData.map((d, i, arr) => {
        //localestring convert num to str and adds in commas. 
        if (i === 0) return `< ${arr[i + 1].toLocaleString()}`;
        if (i === arr.length - 1) return `> ${arr[i].toLocaleString()}`;
        return `${arr[i].toLocaleString()} - ${arr[i + 1].toLocaleString()}`;
      });

      const legendItemHeight = 20;

      // adding legend color boxes
      legend.selectAll("rect")
        .data(legendData)
        .enter()
        .append("rect")
        .attr("x", 0)
        .attr("y", (d, i) => i * legendItemHeight + 20)
        .attr("width", 20)
        .attr("height", 20)
        .attr("fill", d => colorScale(d));

      // adding labels to the legend
      legend.selectAll("text.legend-label")
        .data(legendLabels)
        .enter()
        .append("text")
        .attr("class", "legend-label")
        .attr("x", 30)
        .attr("y", (d, i) => i * legendItemHeight + 35)
        .text(d => d);
    });
  });
</script>